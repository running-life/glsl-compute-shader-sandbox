#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D image;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform vec3 backgroundColor;

// AABB for ray marching
uniform vec3 aabbMin;
uniform vec3 aabbMax;

uniform float stepSize;

// BVH node structure
struct BVHNode {
    vec4 aabbMin;    // xyz = min bounds, w = leftChild index (or -1 if leaf)
    vec4 aabbMax;    // xyz = max bounds, w = rightChild index (or sphere count if leaf)
    uvec4 data;      // x = first sphere index (if leaf), y = sphere count (if leaf)
};

struct Sphere {
    vec4 centerAndRadius;
    vec4 color;
};

// Buffers
layout(std140, binding = 1) uniform SphereBuffer {
    int numSpheres;
    Sphere spheres[64];
};

// BVH buffers
layout(std140, binding = 2) uniform BVHBuffer {
    int nodeCount;
    BVHNode nodes[100];
};

layout(std140, binding = 3) uniform SphereIndexBuffer {
    uint sphereIndices[64];
};

// Ray-AABB intersection function
bool rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tMin, out float tMax) {
    vec3 invDir = 1.0 / rayDir;
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    
    vec3 tMinVec = min(t0, t1);
    vec3 tMaxVec = max(t0, t1);
    
    tMin = max(max(tMinVec.x, tMinVec.y), tMinVec.z);
    tMax = min(min(tMaxVec.x, tMaxVec.y), tMaxVec.z);
    
    return tMax > tMin && tMax > 0.0;
}

// Point-in-AABB test
bool isPointInAABB(vec3 point, vec3 aabbMin, vec3 aabbMax) {
    return all(greaterThanEqual(point, aabbMin)) && all(lessThanEqual(point, aabbMax));
}

// BVH-accelerated sphere count at a point
int countSpheresAtPointBVH(vec3 samplePoint) {
    const int MAX_STACK_SIZE = 32;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
    int sphereCount = 0;
    
    if (nodeCount == 0) return 0;
    
    // Start with root node
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        
        BVHNode node = nodes[nodeIndex];
        
        // Check if point is inside node's AABB
        if (!isPointInAABB(samplePoint, node.aabbMin.xyz, node.aabbMax.xyz)) {
            continue;
        }
        
        // Check if it's a leaf node
        if (node.aabbMin.w == -1) {
            // Leaf node - check spheres
            uint firstSphereIndex = node.data.x;
            uint numSpheresInLeaf = uint(node.aabbMax.w);
            
            for (uint i = 0; i < numSpheresInLeaf; i++) {
                uint sphereIdx = sphereIndices[firstSphereIndex + i];
                if (sphereIdx >= numSpheres) break;
                
                vec3 sphereCenter = spheres[sphereIdx].centerAndRadius.xyz;
                float sphereRadius = spheres[sphereIdx].centerAndRadius.w;
                
                if (distance(samplePoint, sphereCenter) <= sphereRadius) {
                    sphereCount++;
                }
            }
        } else {
            // Internal node - add children to stack
            int leftChild = int(node.aabbMin.w);
            int rightChild = int(node.aabbMax.w);
            
            if (stackPtr < MAX_STACK_SIZE - 2) {
                if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
                if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
            }
        }
    }
    
    return sphereCount;
}

// Combined BVH traversal that both counts spheres and finds next intersection
struct TraversalResult {
    int sphereCount;     // Number of spheres at current point
    float nextHitDist;   // Distance to next potential intersection
};

TraversalResult traverseBVH(vec3 samplePoint, vec3 rayOrigin, vec3 rayDir, float currentT, float maxT) {
    TraversalResult result;
    result.sphereCount = 0;
    result.nextHitDist = maxT - currentT; // Initialize to max distance
    
    const int MAX_STACK_SIZE = 32;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
        
    // Start with root node
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        
        BVHNode node = nodes[nodeIndex];
        bool pointInNode = isPointInAABB(samplePoint, node.aabbMin.xyz, node.aabbMax.xyz);
        
        // Ray-AABB intersection for finding next hit
        float tMin, tMax;
        bool rayHitsNode = rayAABBIntersection(rayOrigin, rayDir, node.aabbMin.xyz, node.aabbMax.xyz, tMin, tMax);
        
        // Adjust for current ray position
        if (rayHitsNode) {
            tMin = max(0.0, tMin - currentT);
            
            // If this is further than closest found so far, we can skip ray intersection work
            if (tMin >= result.nextHitDist) {
                rayHitsNode = false;
            }
        }
        
        // Check if it's a leaf node
        if (node.aabbMin.w == -1) {
            // Leaf node - check spheres if point is inside node
            if (pointInNode) {
                uint firstSphereIndex = node.data.x;
                uint numSpheresInLeaf = uint(node.aabbMax.w);
                
                for (uint i = 0; i < numSpheresInLeaf; i++) {
                    uint sphereIdx = sphereIndices[firstSphereIndex + i];
                    if (sphereIdx >= numSpheres) break;
                    
                    vec3 sphereCenter = spheres[sphereIdx].centerAndRadius.xyz;
                    float sphereRadius = spheres[sphereIdx].centerAndRadius.w;
                    
                    if (distance(samplePoint, sphereCenter) <= sphereRadius) {
                        result.sphereCount++;
                    }
                }
            }
            
            // Update next hit distance if this node contains spheres
            if (rayHitsNode && uint(node.aabbMax.w) > 0) {
                result.nextHitDist = min(result.nextHitDist, tMin);
            }
        } else {
            // Internal node - add children to stack
            int leftChild = int(node.aabbMin.w);
            int rightChild = int(node.aabbMax.w);
            
            if (stackPtr < MAX_STACK_SIZE - 2) {
                // Prioritize closer node for both point checking and ray intersection
                // float distLeft = distance(nodes[leftChild].aabbMin.xyz, rayOrigin);
                // float distRight = distance(nodes[rightChild].aabbMin.xyz, rayOrigin);
                
                // if (distLeft <= distRight) {
                //     // Push farther node first (LIFO stack)
                //     if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                //     if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
                // } else {
                //     if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
                //     if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                // }

                if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                if (leftChild < nodeCount) stack[stackPtr++] = leftChild;

            }
        }
    }
    
    return result;
}

void main() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0);
    float aspect = float(size.x) / float(size.y);
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );
    
    // Default background color
    vec3 finalColor = backgroundColor;
    
    float tMin, tMax;
    if (rayAABBIntersection(cameraPosition, rayDirection, aabbMin, aabbMax, tMin, tMax)) {
        // Ray marching parameters
        float t = max(tMin, 0.0);  // Start at entry point or camera if inside
        
        // Color accumulation
        float density = 0.0;
        float maxDensity = 70.0; // For normalization
        
        while (t < tMax) {
            vec3 samplePoint = cameraPosition + t * rayDirection;
            TraversalResult traversalResult = traverseBVH(samplePoint, cameraPosition, rayDirection, t, tMax);

            density += float(traversalResult.sphereCount);
            
            if (traversalResult.sphereCount > 0) {
                // If we found spheres, update the next hit distance
                t += stepSize;
            } else {
                // No spheres found, just step forward
                t += max(traversalResult.nextHitDist, stepSize);
            }
        }
        
        // Normalize density and map to color
        float normalizedDensity = min(density / maxDensity, 1.0);
        
        // Simple color gradient based on density
        if (normalizedDensity > 0.0) {
            // Cool to warm color map
            vec3 coolColor = vec3(0.0, 0.0, 0.6);  // Deep blue
            vec3 warmColor = vec3(1.0, 0.4, 0.0);  // Orange
            
            finalColor = mix(coolColor, warmColor, normalizedDensity);
            
            // Add brightness based on density
            float brightness = 0.5 + 0.5 * normalizedDensity;
            finalColor *= brightness;
        }
    }
    
    imageStore(image, gidx, vec4(finalColor, 1.0));
}