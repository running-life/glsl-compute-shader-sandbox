#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D image;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform vec3 backgroundColor;

// AABB for ray marching
uniform vec3 aabbMin;
uniform vec3 aabbMax;

uniform float stepSize;

// sun position
uniform vec3 sunPosition;

// BVH node structure
struct BVHNode {
    vec4 aabbMin;    // xyz = min bounds, w = leftChild index (or -1 if leaf)
    vec4 aabbMax;    // xyz = max bounds, w = rightChild index (or sphere count if leaf)
    uvec4 data;      // x = first sphere index (if leaf), y = sphere count (if leaf)
};

struct Sphere {
    vec4 centerAndRadius;
    vec4 color;
};

// Buffers
layout(std140, binding = 1) uniform SphereBuffer {
    int numSpheres;
    Sphere spheres[64];
};

// BVH buffers
layout(std140, binding = 2) uniform BVHBuffer {
    int nodeCount;
    BVHNode nodes[150];
};

// Structure to store candidate sphere information
struct CandidateSphere {
    int sphereIndex;  // Index of the sphere
    float tEnter;     // Enter distance along ray
    float tExit;      // Exit distance along ray
};

const int MAX_CANDIDATE_SPHERES = 5;
const int MAX_SUN_RAY_STEPS = 5;

// Ray-AABB intersection function
bool rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tMin, out float tMax) {
    vec3 invDir = 1.0 / rayDir;
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    
    vec3 tMinVec = min(t0, t1);
    vec3 tMaxVec = max(t0, t1);
    
    tMin = max(max(tMinVec.x, tMinVec.y), tMinVec.z);
    tMax = min(min(tMaxVec.x, tMaxVec.y), tMaxVec.z);
    
    return tMax > tMin && tMax > 0.0;
}

// Ray-sphere intersection test with distance information
bool raySphereIntersection(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius, out float tEnter, out float tExit) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant < 0.0) {
        return false;
    }
    
    float sqrtDiscr = sqrt(discriminant);
    tEnter = (-b - sqrtDiscr) / (2.0 * a);
    tExit = (-b + sqrtDiscr) / (2.0 * a);
    
    return true;
}

// Collect candidate spheres that may intersect the ray
void collectCandidateSpheres(
    vec3 rayOrigin, 
    vec3 rayDir, 
    float tMin, 
    float tMax, 
    out CandidateSphere candidates[MAX_CANDIDATE_SPHERES], 
    out int candidateCount
) {
    candidateCount = 0;
    
    const int MAX_STACK_SIZE = 32;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
    
    // Start with root node
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0 && candidateCount < MAX_CANDIDATE_SPHERES) {
        int nodeIndex = stack[--stackPtr];
        
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        
        BVHNode node = nodes[nodeIndex];
        
        float nodeTMin, nodeTMax;
        bool rayHitsNode = rayAABBIntersection(
            rayOrigin, 
            rayDir, 
            node.aabbMin.xyz, 
            node.aabbMax.xyz, 
            nodeTMin, 
            nodeTMax
        );
        
        // Skip if no intersection or intersection is outside our range
        if (!rayHitsNode || nodeTMax < tMin || nodeTMin > tMax) {
            continue;
        }
        
        if (node.aabbMin.w == -1.0) {
            // Leaf node - add its sphere to candidates if it intersects the ray
            int sphereIndex = int(node.data.w);
            vec3 sphereCenter = spheres[sphereIndex].centerAndRadius.xyz;
            float sphereRadius = spheres[sphereIndex].centerAndRadius.w;
            
            float sphereTMin, sphereTMax;
            if (raySphereIntersection(rayOrigin, rayDir, sphereCenter, sphereRadius, sphereTMin, sphereTMax)) {
                // Only consider intersection if it's within our ray segment
                if (sphereTMax >= tMin && sphereTMin <= tMax) {
                    if (candidateCount < MAX_CANDIDATE_SPHERES) {
                        candidates[candidateCount].sphereIndex = sphereIndex;
                        candidates[candidateCount].tEnter = max(sphereTMin, tMin);
                        candidates[candidateCount].tExit = min(sphereTMax, tMax);
                        candidateCount++;
                    }
                }
            }
        } else {
            // Internal node - add children to stack
            int leftChild = int(node.aabbMin.w);
            int rightChild = int(node.aabbMax.w);
            
            if (stackPtr < MAX_STACK_SIZE - 2) {
                if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
            }
        }
    }
    
    // Sort candidates by enter distance (simple insertion sort)
    for (int i = 1; i < candidateCount; i++) {
        CandidateSphere key = candidates[i];
        int j = i - 1;
        
        while (j >= 0 && candidates[j].tEnter > key.tEnter) {
            candidates[j + 1] = candidates[j];
            j--;
        }
        
        candidates[j + 1] = key;
    }
}

void collectCandidateSpheres2(
    vec3 rayOrigin, 
    vec3 rayDir, 
    float tMin, 
    float tMax, 
    out CandidateSphere candidates[MAX_CANDIDATE_SPHERES], 
    out int candidateCount
) {
    candidateCount = 0;
    
    const int MAX_STACK_SIZE = 32;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
    
    // Start with root node
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0 && candidateCount < MAX_CANDIDATE_SPHERES) {
        int nodeIndex = stack[--stackPtr];
        
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        
        BVHNode node = nodes[nodeIndex];
        
        float nodeTMin, nodeTMax;
        bool rayHitsNode = rayAABBIntersection(
            rayOrigin, 
            rayDir, 
            node.aabbMin.xyz, 
            node.aabbMax.xyz, 
            nodeTMin, 
            nodeTMax
        );
        
        // Skip if no intersection or intersection is outside our range
        if (!rayHitsNode || nodeTMax < tMin || nodeTMin > tMax) {
            continue;
        }
        
        if (node.aabbMin.w == -1.0) {
            // Leaf node - add its sphere to candidates

            candidates[candidateCount].sphereIndex = int(node.data.w);
            candidates[candidateCount].tEnter = max(nodeTMin, tMin);
            candidates[candidateCount].tExit = min(nodeTMax, tMax);
            candidateCount++;
        } else {
            // Internal node - add children to stack
            int leftChild = int(node.aabbMin.w);
            int rightChild = int(node.aabbMax.w);
            
            if (stackPtr < MAX_STACK_SIZE - 2) {
                if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
            }
        }
    }
    
    // Sort candidates by enter distance (simple insertion sort)
    for (int i = 1; i < candidateCount; i++) {
        CandidateSphere key = candidates[i];
        int j = i - 1;
        
        while (j >= 0 && candidates[j].tEnter > key.tEnter) {
            candidates[j + 1] = candidates[j];
            j--;
        }
        
        candidates[j + 1] = key;
    }
}

// Check if a point is inside any sphere from the candidate list
int countSpheresAtPoint(vec3 point, CandidateSphere candidates[MAX_CANDIDATE_SPHERES], int candidateCount, float currentT) {
    int count = 0;
    
    // Process candidates that are relevant at this distance
    for (int i = 0; i < candidateCount; i++) {
        // Skip spheres we've already passed
        if (currentT > candidates[i].tExit) {
            continue;
        }
        
        // Skip spheres we haven't reached yet
        if (currentT < candidates[i].tEnter) {
            break; // Since they're sorted, we can break here
        }
        
        // Check if point is inside sphere
        vec3 sphereCenter = spheres[candidates[i].sphereIndex].centerAndRadius.xyz;
        float sphereRadius = spheres[candidates[i].sphereIndex].centerAndRadius.w;
        
        if (distance(point, sphereCenter) <= sphereRadius) {
            count++;
        }
    }
    
    return count;
}

// dynamic step size
int countSpheresAtPoint2(vec3 point, CandidateSphere candidates[MAX_CANDIDATE_SPHERES], int candidateCount, float currentT, inout int startIdx, inout float nextT) {
    int count = 0;
    
    if (currentT < candidates[startIdx].tEnter) {
        nextT = max(candidates[startIdx].tEnter, nextT);
        return 0;
    }
    
    // Process candidates that are relevant at this distance
    for (int i = startIdx; i < candidateCount; i++) {
        // Skip spheres we've already passed
        if (currentT > candidates[i].tExit) {
            startIdx = i + 1;
            continue;
        }
        
        // Skip spheres we haven't reached yet
        if (currentT < candidates[i].tEnter) {
            break; // Since they're sorted, we can break here
        }
        
        // Check if point is inside sphere
        vec3 sphereCenter = spheres[candidates[i].sphereIndex].centerAndRadius.xyz;
        float sphereRadius = spheres[candidates[i].sphereIndex].centerAndRadius.w;
        
        if (distance(point, sphereCenter) <= sphereRadius) {
            count++;
        }
    }
    
    return count;
}

int countSphereOfSunRay(vec3 startPoint) {
    CandidateSphere candidatesOfSunRay[MAX_CANDIDATE_SPHERES];
    int candidateCountOfSunRay;

    vec3 sunRayDirection = normalize(sunPosition - startPoint);
    float tSunRay = stepSize;
    collectCandidateSpheres(startPoint, sunRayDirection, tSunRay, 100000, candidatesOfSunRay, candidateCountOfSunRay);

    int stepNum = MAX_SUN_RAY_STEPS;
    int startIdxOfSunRay = 0;

    int res = 0;

    while(stepNum-- > 0) {
        vec3 samplePointSunRay = startPoint + tSunRay * sunRayDirection;
        int sphereCountSunRay = countSpheresAtPoint(samplePointSunRay, candidatesOfSunRay, candidateCountOfSunRay, tSunRay);
        tSunRay += stepSize;
        // int sphereCountSunRay = countSpheresAtPoint2(samplePointSunRay, candidatesOfSunRay, candidateCountOfSunRay, tSunRay - stepSize, startIdxOfSunRay, tSunRay);
        res += sphereCountSunRay;
    }
    return res;
}

int countSphereOfSunRay2(vec3 startPoint) {
    int candidateSet[MAX_CANDIDATE_SPHERES];
    int candidateCount = 0;

    vec3 sunRayDirection = normalize(sunPosition - startPoint);
    float tSunRay = stepSize;

    float tMin = stepSize;
    float tMax = 10000;

    const int MAX_STACK_SIZE = 10;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;

    stack[stackPtr++] = 0;

    while (stackPtr > 0 && candidateCount < MAX_CANDIDATE_SPHERES) {
        int nodeIndex = stack[--stackPtr];
        
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;

        BVHNode node = nodes[nodeIndex];
        
        float nodeTMin, nodeTMax;
        bool rayHitsNode = rayAABBIntersection(startPoint, sunRayDirection, node.aabbMin.xyz, node.aabbMax.xyz, nodeTMin, nodeTMax);

        // Only consider intersections within our tMin-tMax range
        if (!rayHitsNode || nodeTMax < tMin || nodeTMin > tMax) {
            continue;
        }

        if (node.aabbMin.w == -1.0) {
            // Leaf node - add its sphere to candidates
            candidateSet[candidateCount++] = int(node.data.w);
        } else {
            // Internal node - add children to stack
            int leftChild = int(node.aabbMin.w);
            int rightChild = int(node.aabbMax.w);

            if (stackPtr < MAX_STACK_SIZE - 2) {
                if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
            }
        }
    }

    int res = 0;
    int stepNum = MAX_SUN_RAY_STEPS;
    while(stepNum-- > 0) {
        vec3 samplePointSunRay = startPoint + tSunRay * sunRayDirection;
        for(int i = 0; i < candidateCount; ++i) {
            int sphereIdx = candidateSet[i];
            vec3 sphereCenter = spheres[sphereIdx].centerAndRadius.xyz;
            float sphereRadius = spheres[sphereIdx].centerAndRadius.w;
            
            if (distance(samplePointSunRay, sphereCenter) <= sphereRadius) {
                res++;
            }
        }
    }
    
    return res;
}


void main() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0);
    float aspect = float(size.x) / float(size.y);
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );
    
    // Default background color
    vec3 finalColor = backgroundColor;
    
    float tMin, tMax;
    if (rayAABBIntersection(cameraPosition, rayDirection, aabbMin, aabbMax, tMin, tMax)) {
        // Ray marching parameters
        float t = max(tMin, 0.0);  // Start at entry point or camera if inside
        
        // Collect all candidate spheres for this ray
        CandidateSphere candidates[MAX_CANDIDATE_SPHERES];
        int candidateCount;
        collectCandidateSpheres(cameraPosition, rayDirection, t, tMax, candidates, candidateCount);

        // Color accumulation
        float density = 0.0;
        float maxDensity = 70.0; // For normalization
        
        // March along the ray
        float tNext = t;
        int startIdx = 0;
        while (t < tMax) {
            vec3 samplePoint = cameraPosition + t * rayDirection;
            // int sphereCount = countSpheresAtPoint(samplePoint, candidates, candidateCount, t);
            t += stepSize;
            int sphereCount = countSpheresAtPoint2(samplePoint, candidates, candidateCount, t - stepSize, startIdx, t);

            if (sphereCount == 0) {
                continue;
            }

            density += float(sphereCount);
            // density += float(countSphereOfSunRay(samplePoint));
            density += float(countSphereOfSunRay2(samplePoint));

        }
        
        // Normalize density and map to color
        float normalizedDensity = min(density / maxDensity, 1.0);
        
        // Simple color gradient based on density
        if (normalizedDensity > 0.0) {
            // Cool to warm color map
            vec3 coolColor = vec3(0.0, 0.0, 0.6);  // Deep blue
            vec3 warmColor = vec3(1.0, 0.4, 0.0);  // Orange
            
            finalColor = mix(coolColor, warmColor, normalizedDensity);
            
            // Add brightness based on density
            float brightness = 0.5 + 0.5 * normalizedDensity;
            finalColor *= brightness;
        }
    }
    
    imageStore(image, gidx, vec4(finalColor, 1.0));
}