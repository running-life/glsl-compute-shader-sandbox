#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D image;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform vec3 backgroundColor;

// AABB for ray marching
uniform vec3 aabbMin;
uniform vec3 aabbMax;

uniform float stepSize;

// BVH node structure
struct BVHNode {
    vec4 aabbMin;    // xyz = min bounds, w = leftChild index (or -1 if leaf)
    vec4 aabbMax;    // xyz = max bounds, w = rightChild index (or sphere count if leaf)
    uvec4 data;      // x = first sphere index (if leaf), y = sphere count (if leaf)
};

struct Sphere {
    vec4 centerAndRadius;
    vec4 color;
};

// Buffers
layout(std140, binding = 1) uniform SphereBuffer {
    int numSpheres;
    Sphere spheres[64];
};

// BVH buffers
layout(std140, binding = 2) uniform BVHBuffer {
    int nodeCount;
    BVHNode nodes[150];
};

// Structure to hold candidate spheres
struct CandidateSet {
    int count;
    int indices[64]; // Assuming maximum 64 candidate spheres
};

// Ray-AABB intersection function
bool rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tMin, out float tMax) {
    vec3 invDir = 1.0 / rayDir;
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    
    vec3 tMinVec = min(t0, t1);
    vec3 tMaxVec = max(t0, t1);
    
    tMin = max(max(tMinVec.x, tMinVec.y), tMinVec.z);
    tMax = min(min(tMaxVec.x, tMaxVec.y), tMaxVec.z);
    
    return tMax > tMin && tMax > 0.0;
}

// Point-in-AABB test
bool isPointInAABB(vec3 point, vec3 aabbMin, vec3 aabbMax) {
    return all(greaterThanEqual(point, aabbMin)) && all(lessThanEqual(point, aabbMax));
}

// Collect all spheres that potentially intersect with the ray
CandidateSet collectCandidateSpheres(vec3 rayOrigin, vec3 rayDir, float tMin, float tMax) {
    CandidateSet candidates;
    candidates.count = 0;

    const int MAX_STACK_SIZE = 32;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;

    // Start with root node
    stack[stackPtr++] = 0;

    while (stackPtr > 0 && candidates.count < 64) {
        int nodeIndex = stack[--stackPtr];
        
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;

        BVHNode node = nodes[nodeIndex];
        
        float nodeTMin, nodeTMax;
        bool rayHitsNode = rayAABBIntersection(rayOrigin, rayDir, node.aabbMin.xyz, node.aabbMax.xyz, nodeTMin, nodeTMax);

        // Only consider intersections within our tMin-tMax range
        if (!rayHitsNode || nodeTMax < tMin || nodeTMin > tMax) {
            continue;
        }

        if (node.aabbMin.w == -1.0) {
            // Leaf node - add its sphere to candidates
            candidates.indices[candidates.count++] = int(node.data.w);
        } else {
            // Internal node - add children to stack
            int leftChild = int(node.aabbMin.w);
            int rightChild = int(node.aabbMax.w);

            if (stackPtr < MAX_STACK_SIZE - 2) {
                if (rightChild < nodeCount) stack[stackPtr++] = rightChild;
                if (leftChild < nodeCount) stack[stackPtr++] = leftChild;
            }
        }
    }
    
    return candidates;
}

void main() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0);
    float aspect = float(size.x) / float(size.y);
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );
    
    // Default background color
    vec3 finalColor = backgroundColor;
    
    float tMin, tMax;
    if (rayAABBIntersection(cameraPosition, rayDirection, aabbMin, aabbMax, tMin, tMax)) {
        // Ray marching parameters
        float t = max(tMin, 0.0);  // Start at entry point or camera if inside
        
        // Collect candidate spheres that might intersect with the ray
        CandidateSet candidates = collectCandidateSpheres(cameraPosition, rayDirection, t, tMax);
        
        // Color accumulation
        float density = 0.0;
        float maxDensity = 70.0; // For normalization
        
        while (t < tMax) {
            vec3 samplePoint = cameraPosition + t * rayDirection;
            
            // Check sample point against candidate spheres
            int sphereCount = 0;
            for (int i = 0; i < candidates.count; i++) {
                int sphereIdx = candidates.indices[i];
                vec3 sphereCenter = spheres[sphereIdx].centerAndRadius.xyz;
                float sphereRadius = spheres[sphereIdx].centerAndRadius.w;
                
                if (distance(samplePoint, sphereCenter) <= sphereRadius) {
                    sphereCount++;
                }
            }
            
            density += float(sphereCount);
            t += stepSize;
        }
        
        // Normalize density and map to color
        float normalizedDensity = min(density / maxDensity, 1.0);
        
        // Simple color gradient based on density
        if (normalizedDensity > 0.0) {
            // Cool to warm color map
            vec3 coolColor = vec3(0.0, 0.0, 0.6);  // Deep blue
            vec3 warmColor = vec3(1.0, 0.4, 0.0);  // Orange
            
            finalColor = mix(coolColor, warmColor, normalizedDensity);
            
            // Add brightness based on density
            float brightness = 0.5 + 0.5 * normalizedDensity;
            finalColor *= brightness;
        }
    }
    
    imageStore(image, gidx, vec4(finalColor, 1.0));
}