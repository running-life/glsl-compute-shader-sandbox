#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D image;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;

// Background color
uniform vec3 backgroundColor;

// Sphere data structure
struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
    float padding; // For alignment
};

// Sphere buffer
layout(std430, binding = 1) readonly buffer SphereBuffer {
    int numSpheres;
    Sphere spheres[];
};

// Ray-sphere intersection function
// Returns -1 if no intersection, otherwise returns the distance to the nearest intersection point
float raySphereIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    
    float discriminant = b * b - 4 * a * c;
    
    if (discriminant < 0.0) {
        return -1.0; // No intersection
    } else {
        float sqrt_discriminant = sqrt(discriminant);
        float t1 = (-b - sqrt_discriminant) / (2.0 * a);
        float t2 = (-b + sqrt_discriminant) / (2.0 * a);
        
        // Return the nearest positive intersection
        if (t1 > 0.0) {
            return t1;
        } else if (t2 > 0.0) {
            return t2;
        } else {
            return -1.0; // Both intersections are behind the ray origin
        }
    }
}

void main2() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates (-1 to 1)
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0); // 45 degree field of view
    float aspect = float(size.x) / float(size.y);
    
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );

    vec3 testCenter = vec3(1, 0.0, -5.0);
    float testRadius = 1.0;
    vec3 testColor = vec3(0.8, 0.3, 0.3);

    float t = raySphereIntersection(cameraPosition, rayDirection, testCenter, testRadius);

    vec3 color;
    if (t > 0.0) {
        // Ray hits the sphere
        vec3 hitPoint = cameraPosition + t * rayDirection;
        vec3 normal = normalize(hitPoint - testCenter);
        
        // Simple shading: use dot product with a fixed light direction for basic lighting
        vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
        float lightIntensity = max(dot(normal, lightDirection), 0.2); // Minimum ambient lighting
        
        color = testColor * lightIntensity;
    } else {
        // Ray misses the sphere, use background color
        color = backgroundColor;
    }
    imageStore(image, gidx, vec4(color, 1.0));

    // return;
    
    // Find closest sphere intersection
    float closestT = -1.0;
    vec3 closestColor = color;
    vec3 closestHitPoint;
    vec3 closestNormal;
    
    for (int i = 0; i < numSpheres; i++) {
        float t = raySphereIntersection(cameraPosition, rayDirection, 
                                       spheres[i].center, spheres[i].radius);
        
        if (t > 0.0 && (closestT < 0.0 || t < closestT)) {
            closestT = t;
            closestHitPoint = cameraPosition + t * rayDirection;
            closestNormal = normalize(closestHitPoint - spheres[i].center);
            
            // Simple shading with multiple light sources for cloud-like appearance
            vec3 lightDirection1 = normalize(vec3(1.0, 1.0, 1.0));  // Main sun light
            vec3 lightDirection2 = normalize(vec3(-0.5, 0.8, 0.2)); // Sky ambient
            
            float lightIntensity1 = max(dot(closestNormal, lightDirection1), 0.0);
            float lightIntensity2 = max(dot(closestNormal, lightDirection2), 0.0);
            
            // Add ambient and multiple light contributions
            float ambient = 0.3;
            float diffuse = lightIntensity1 * 0.8 + lightIntensity2 * 0.4;
            
            // Add some atmospheric scattering effect based on distance
            // float atmosphericFade = exp(-t * 0.02); // Fade with distance
            float atmosphericFade = 1.0;
            
            closestColor = spheres[i].color * (ambient + diffuse) * atmosphericFade;
            closestColor = vec3(1.0, 0, 0);
        }
    }
    
    imageStore(image, gidx, vec4(closestColor, 1.0));
}

void main1() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates (-1 to 1)
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0); // 45 degree field of view
    float aspect = float(size.x) / float(size.y);
    
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );

    vec3 testCenter = vec3(0.0, 0.0, -5.0);
    float testRadius = 1.0;
    vec3 testColor = vec3(0.8, 0.3, 0.3);

    float t = raySphereIntersection(cameraPosition, rayDirection, testCenter, testRadius);

    vec3 color;
    if (t > 0.0) {
        // Ray hits the sphere
        vec3 hitPoint = cameraPosition + t * rayDirection;
        vec3 normal = normalize(hitPoint - testCenter);
        
        // Simple shading: use dot product with a fixed light direction for basic lighting
        vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
        float lightIntensity = max(dot(normal, lightDirection), 0.2); // Minimum ambient lighting
        
        color = testColor * lightIntensity;
    } else {
        // Ray misses the sphere, use background color
        color = backgroundColor;
    }
    imageStore(image, gidx, vec4(color, 1.0));

}

void main3() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0);
    float aspect = float(size.x) / float(size.y);
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );
    
    // 初始化为背景色
    vec3 color = backgroundColor;
    float closestT = -1.0;

    // if (numSpheres == 64) {
    //     imageStore(image, gidx, vec4(1.0, 0, 0.0, 1.0));
    //     return;
    // }
    
    // 检查缓冲区中的所有球体
    for (int i = 0; i < numSpheres; i++) {
        float t = raySphereIntersection(cameraPosition, rayDirection, 
                                       spheres[i].center, spheres[i].radius);

        color = spheres[0].color;
        break;

        if (t > 0.0 && (closestT < 0.0 || t < closestT)) {
            closestT = t;
            vec3 hitPoint = cameraPosition + t * rayDirection;
            vec3 normal = normalize(hitPoint - spheres[i].center);
            
            // 简单光照
            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
            float diffuse = max(dot(normal, lightDir), 0.2);
            
            color = spheres[i].color * diffuse;
            break;
        }
    }
    
    // 将结果写入图像
    imageStore(image, gidx, vec4(color, 1.0));
}

void main() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // 进行分区测试，输出不同颜色来确认各种情况
    if (gidx.x < size.x / 3) {
        // 左侧区域：测试 numSpheres
        if (numSpheres > 0) {
            imageStore(image, gidx, vec4(0.0, 1.0, 0.0, 1.0)); // 绿色表示有球体数据
        } else {
            imageStore(image, gidx, vec4(1.0, 0.0, 0.0, 1.0)); // 红色表示没有球体数据
        }
    } 
    else if (gidx.x < 2 * size.x / 3) {
if (numSpheres > 0) {
        float normalizedY = float(gidx.y) / float(size.y);
        
        // Display memory values as colors for visualization
        if (normalizedY < 0.2) {
            // First 3 floats - should be center
            vec3 mem = vec3(spheres[0].center.x, spheres[0].center.y, spheres[0].center.z);
            imageStore(image, gidx, vec4(abs(mem), 1.0));
        }
        else if (normalizedY < 0.4) {
            // Display radius as intensity
            float r = spheres[0].radius;
            imageStore(image, gidx, vec4(r, r, r, 1.0));
        }
        else if (normalizedY < 0.6) {
            // Color components - what we're testing
            vec3 col = spheres[0].color;
            imageStore(image, gidx, vec4(col, 1.0));
        }
        else if (normalizedY < 0.8) {
            // Test if color components are in expected range
            vec3 col = spheres[0].color;
            bool validRange = all(greaterThanEqual(col, vec3(0.0))) && 
                             all(lessThanEqual(col, vec3(1.0)));
            imageStore(image, gidx, vec4(validRange ? 0.0 : 1.0, 1.0, 0.0, 1.0));
        }
        else {
            // Memory address test
            imageStore(image, gidx, vec4(float(numSpheres)/100.0, 0.5, 0.5, 1.0));
        }
    } else {
        imageStore(image, gidx, vec4(1.0, 1.0, 0.0, 1.0)); // Yellow - no spheres
    }
    } 
    else {
        // 右侧区域：测试碰撞检测
        vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
        vec3 rayDirection = normalize(
            cameraFront + 
            tan(radians(45.0) * 0.5) * (ndc.x * float(size.x)/float(size.y) * cameraRight + ndc.y * cameraUp)
        );
        
        // 测试与第一个球体的碰撞
        if (numSpheres > 0) {
            float t = raySphereIntersection(cameraPosition, rayDirection, 
                                           spheres[0].center, spheres[0].radius);
            if (t > 0.0) {
                // 碰撞时显示蓝色
                imageStore(image, gidx, vec4(0.0, 0.0, 1.0, 1.0));
            } else {
                // 无碰撞时显示背景色
                imageStore(image, gidx, vec4(backgroundColor, 1.0));
            }
        } else {
            imageStore(image, gidx, vec4(0.5, 0.5, 0.5, 1.0)); // 灰色
        }
    }
}