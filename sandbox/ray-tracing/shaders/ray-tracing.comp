#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D image;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;

// Sphere uniforms
uniform vec3 sphereCenter;
uniform float sphereRadius;
uniform vec3 sphereColor;
uniform vec3 backgroundColor;

// Ray-sphere intersection function
// Returns -1 if no intersection, otherwise returns the distance to the nearest intersection point
float raySphereIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    
    float discriminant = b * b - 4 * a * c;
    
    if (discriminant < 0.0) {
        return -1.0; // No intersection
    } else {
        float sqrt_discriminant = sqrt(discriminant);
        float t1 = (-b - sqrt_discriminant) / (2.0 * a);
        float t2 = (-b + sqrt_discriminant) / (2.0 * a);
        
        // Return the nearest positive intersection
        if (t1 > 0.0) {
            return t1;
        } else if (t2 > 0.0) {
            return t2;
        } else {
            return -1.0; // Both intersections are behind the ray origin
        }
    }
}

void main() {
    ivec2 gidx = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    // Convert pixel coordinates to normalized device coordinates (-1 to 1)
    vec2 ndc = (2.0 * vec2(gidx) - vec2(size)) / float(size.y);
    
    // Create ray from camera
    float fov = radians(45.0); // 45 degree field of view
    float aspect = float(size.x) / float(size.y);
    
    vec3 rayDirection = normalize(
        cameraFront + 
        tan(fov * 0.5) * (ndc.x * aspect * cameraRight + ndc.y * cameraUp)
    );
    
    // Perform ray-sphere intersection
    float t = raySphereIntersection(cameraPosition, rayDirection, sphereCenter, sphereRadius);
    
    vec3 color;
    if (t > 0.0) {
        // Ray hits the sphere
        vec3 hitPoint = cameraPosition + t * rayDirection;
        vec3 normal = normalize(hitPoint - sphereCenter);
        
        // Simple shading: use dot product with a fixed light direction for basic lighting
        vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
        float lightIntensity = max(dot(normal, lightDirection), 0.2); // Minimum ambient lighting
        
        color = sphereColor * lightIntensity;
    } else {
        // Ray misses the sphere, use background color
        color = backgroundColor;
    }
    
    imageStore(image, gidx, vec4(color, 1.0));
}
